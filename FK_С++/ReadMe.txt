
В данном проекте реализована фильтрация данных с использованием фильтра Калмана.

Алгоритм фильтра Калмана:

1. Предсказание состояния системы
xk_ = F * xk + B*uk,
где xk_ - предсказание состояния системы в текущий момент времени, 
xk - состояние системы в прошлый момент времени,
F - матрица перехода между состояниями,
B - матрица применения управляющего воздействия,
uk - управляющее воздействие в прошлый момент времени.
2. Предсказание ошибки ковариации
P_ = F * P * FT + Q,
где P_ - предсказание ошибки,
P - ошибка в прошлый момент времени,
FT - транспонированная матрица F,
Q - ковариация шума процесса.
3. Вычисление усиления Калмана
K = P_ * HT / (H * P_ * HT + R),
K - усиление Калмана,
H - матрица измерений, отображающая отношение измерений и состояний,
HT - транспонированная матрица H,
R - ковариация шума измерения.
4. Обновление оценки с учетом измерения 
xk = xk_ + K * (y - H * xk_),
xk - состояние системы,
y - измерение в текущий момент времени.
5. Обновление ошибки ковариации
P = (I - K * H) * P,
где I - единичная матрица.

Так как состояние системы представлено одной переменной(угол азимута или угол наклона), матрицы вырождаются в переменные. В связи с тем, что нет информации о динамике системы, переменной F присваивается 1. Для использования переменной H необходимо знать уравнение исходной функции, так как данной инфоормации нет, ей присваивается 1. Переменная B = 0, так как в используемой модели нет управляющих воздействий(они нам неизвестны). Фильтр Калмана в результате изменений выглядит следующим образом:
1. xk_ = xk;
2. P_ = P + Q;
3. K = P_ / (P_ + R);
4. xk = xk_ + K * (y - xk_);
5. P = (1 - K) * P.
В проекте фильтр Калмана используется дважды. Для второго фильтра значения R и Q остаются теми же, при предсказании ошибки используется обновленная ошибка из первого фильтра, вместо текущего измерения используется результат обработки первого фильтра.  
Функция обработки возвращает значение: xk = xk1 - (xk2 - xk1), 
где xk1 - результат первой фильтрации,
xk2 - результат второй фильтрации. 
Алгоритм обработки:
1. P = P + Q;
2. K = P / (P + R);
3. P = (1 - K) * P
4. xk1 = (d + xk) + K * (y - (d + xk)), 
где d = xk2 - xk1,
xk - результат прошлой обработки;
5. P = P + Q;
6. K = P / (P + R);
7. P = (1 - K) * P;
8. d = ((2 * d + xk) + K * (xk1 - (2 * d + xk))) - xk1;
9. xk = xk1 - d;